# Engma Architecture Overview

## Core Philosophy: Ultra-Minimalism

Engma embodies an ultra-minimalist design philosophy where **every line of code serves a purpose** and **zero-cost abstractions** are the foundation. The engine achieves maximum performance through compile-time polymorphism, eliminating runtime overhead while maintaining flexibility.

## System Architecture

### Meta-Engine Framework
Engma is a **meta-engine** - it provides generic abstractions over concrete implementations without runtime cost. The engine uses Zig's comptime features to resolve all polymorphism at compile time.

```zig
const Engine = struct {
    systems: struct {
        world: engma.world.greedy,      // Swappable world representation
        gfx: engma.lib.render(engma.shader.cube),  // Parameterized renderer
        body: engma.player.quake,       // Quake-style player system
        keys: engma.lib.input,          // Input abstraction
        audio: engma.lib.audio,         // Audio system
        debug: engma.lib.debug,         // Debug utilities
    },
};
```

### Universal System Interface
All systems implement the same interface, called via compile-time reflection:

```zig
fn init(system: *System, engine: Engine) void
fn tick(system: *System, engine: Engine) void  
fn draw(system: *System, engine: Engine) void
fn event(system: *System, engine: Engine) void
fn deinit(system: *System, engine: Engine) void
```

This enables the engine to orchestrate all systems uniformly:

```zig
fn call(self: *Engine, comptime system: []const u8) void {
    inline for (@typeInfo(@TypeOf(self.systems)).@"struct".fields) |field| {
        @call(.auto, @field(@TypeOf(@field(self.systems, field.name)), system), 
              .{&@field(self.systems, field.name)} ++ .{self.*});
    }
}
```

## Module Structure

```
src/engma/
├── mod.zig              # Module exports and interface definitions
├── lib/                 # Core engine libraries
│   ├── math.zig         # SIMD vector/matrix operations
│   ├── input.zig        # Input state management
│   ├── render.zig       # Generic rendering abstraction
│   ├── audio.zig        # Audio system
│   └── debug.zig        # Debug utilities
├── world/               # Swappable world representations
│   ├── voxel.zig        # Basic voxel world
│   └── greedy.zig       # Optimized greedy meshing
├── physics/             # Pluggable physics systems
│   └── basic.zig        # Simple physics
├── player/              # Player implementations
│   ├── basic/           # Basic player (hyperminimal modules)
│   │   ├── mod.zig      # Player interface
│   │   ├── physics.zig  # Hyperminimal physics
│   │   ├── collision.zig # Hyperminimal collision
│   │   └── config.zig   # Hyperminimal config
│   └── quake/           # Quake-style player (full modules)
│       ├── mod.zig      # Player interface
│       ├── physics.zig  # Movement physics
│       ├── collision.zig # Collision detection
│       └── config.zig   # Configuration constants
└── shader/              # Shader modules
    └── cube/            # Basic cube shader
        ├── mod.zig      # Shader interface
        ├── shader.glsl  # GLSL source
        └── shader.glsl.zig  # Generated bytecode
```

## Key Design Principles

### 1. Zero-Cost Abstractions
- All polymorphism resolved at compile time
- No virtual function calls or dynamic dispatch
- Generic types parameterized at compile time
- Interface compliance verified statically

### 2. Compile-Time Configuration
- Systems are swappable via type parameters
- Renderer parameterized by shader type: `render(ShaderType)`
- World representations interchangeable
- Physics systems pluggable

### 3. Data-Oriented Design
- Minimal indirection and pointer chasing
- Cache-friendly data layouts
- SIMD operations for vector math
- Bitpacked data structures for efficiency

### 4. Minimal Dependencies
- Core engine depends only on Zig standard library
- Platform abstraction via sokol-zig
- Shader compilation via shdc
- Optional ImGui for debug UI

### 5. Cross-Platform by Design
- Single codebase for native and web (WASM)
- Shader compilation to multiple targets
- Platform-specific optimizations via comptime

## Performance Features

### SIMD Vector Operations
```zig
pub const Vec3 = struct {
    v: @Vector(3, f32),  // Hardware SIMD vector
    
    pub fn add(a: Vec3, b: Vec3) Vec3 {
        return .{ .v = a.v + b.v };  // Single SIMD instruction
    }
};
```

### Bitpacked Voxel Storage
- 4096 voxels compressed to 512 bytes (8:1 ratio)
- Bit manipulation for O(1) voxel access
- Cache-efficient storage layout

### Greedy Meshing Algorithm
- O(n) mesh generation where n = visible faces
- Face culling and merging
- Minimal GPU memory usage

### GPU-Resident Geometry
- Vertex/index buffers uploaded once
- Minimal CPU-GPU data transfers
- Uniform buffer for transformation matrices

## System Interfaces

### World System Contract
```zig
fn get(x: i32, y: i32, z: i32) bool           // Voxel query
fn mesh(vertices: []Vertex, indices: []u16) Mesh  // Mesh generation
```

### Physics System Contract  
```zig
fn view() Mat4                    // Camera transformation
fn mouse(dx: f32, dy: f32) void  // Mouse input handling
```

### Renderer Contract
```zig
fn init(self: *Self, engine: Engine) void
fn draw(self: *Self, engine: Engine) void
```

This architecture enables swapping implementations without changing client code, achieving both flexibility and performance through Zig's powerful compile-time system.