ENGMA(1)                    General Commands Manual                   ENGMA(1)

NAME
     engma - engine (meta): brutalist meta-engine framework

SYNOPSIS
     engma [options]
     zig build run

DESCRIPTION
     engma is a hyper-minimalist, swappable meta-engine implementing pure 
     abstraction over concrete implementations. The system provides compile-time
     dependency injection through Zig's type system, enabling zero-cost 
     polymorphism across world representations, physics solvers, and rendering
     backends.

ARCHITECTURE
     The engine follows a strict modular hierarchy:

     src/
     ├── main.zig              # Configuration matrix and entry point
     └── engine/               # Self-contained engine module
         ├── mod.zig               # Namespace system + Engine(Config)
         ├── lib/
         │   ├── math.zig          # SIMD vector/matrix primitives  
         │   └── input.zig         # Event-driven input state machine
         ├── world/
         │   ├── voxel.zig         # Bitpacked spatial representation
         │   └── empty.zig         # Null world implementation
         ├── physics/
         │   ├── quake.zig         # Quake-style movement solver
         │   └── simple.zig        # Newtonian dynamics
         ├── render/
         │   └── sokol.zig         # Generic mesh rendering pipeline
         └── shader/
             └── cube/             # Modular shader interface
                 ├── mod.zig           # Shader abstraction layer
                 ├── shader.glsl       # GLSL source
                 └── shader.glsl.zig   # Generated bytecode

IMPLEMENTATION SWAPPING
     The meta-engine uses compile-time configuration for zero-cost abstraction:

     const Config = struct {
         pub const World = world.voxel;           // Spatial representation
         pub const Gfx = gfx.sokol(shaders.cube); // Rendering backend
         pub const Body = phys.quake;             // Physics solver
         pub const Keys = lib.input;              // Input handler
     };

     Alternative configurations:
         World: voxel, empty, heightmap, octree
         Gfx: sokol, vulkan, opengl, software
         Body: quake, verlet, rigid, particle
         Keys: input (standard implementation)

MATHEMATICAL FOUNDATIONS
     World Module (35 SLOC):
         - 4096 voxels → 512 bytes via bitpacking
         - Bit operations: bits[i>>3] |= 1<<(i&7)
         - Face culling with 6-directional neighbor queries
         - Mesh generation: O(n) where n = visible faces

     Physics Module (180 SLOC):
         - Quake movement: air control + ground friction
         - AABB swept collision detection
         - Multi-step integration for temporal coherence
         - Spatial partitioning via world.get(x,y,z)

     Math Module (25 SLOC):
         - SIMD @Vector(3,f32) operations
         - Matrix multiplication via compile-time unrolling
         - Projection matrix: perspective(fov, aspect, near, far)

     Render Module (45 SLOC):
         - Generic Mesh{vertices, indices} interface
         - GPU buffer management via sokol-gfx
         - Uniform matrix upload: MVP transformation

INTERFACE CONTRACTS
     All implementations must satisfy these signatures:

     World Interface:
         init() -> World
         get(x: i32, y: i32, z: i32) -> bool
         mesh(vertices: []Vertex, indices: []u16) -> Mesh

     Physics Interface:
         init() -> Player
         tick(world: *World, keys: *Keys, dt: f32) -> void
         view() -> Mat4
         mouse(dx: f32, dy: f32) -> void

     Renderer Interface:
         init() -> Gfx
         draw(world: *World, view: Mat4) -> void
         dt() -> f32
         deinit() -> void

     Input Interface:
         init() -> Keys
         tick() -> void
         event(e: Event) -> void
         forward/back/left/right/jump() -> bool

PERFORMANCE CHARACTERISTICS
     - Zero runtime polymorphism (compile-time dispatch)
     - SIMD vector operations where applicable
     - Bitpacked data structures (8:1 compression ratio)
     - Single-pass mesh generation
     - Temporal coherence in physics integration
     - GPU-resident geometry (no CPU→GPU transfers per frame)

CONTROLS
     WASD        Movement (forward/back/strafe)
     Mouse       Camera orientation (FPS-style)
     Space       Jump (ground detection required)
     LMB         Mouse capture toggle
     Escape      Mouse release

BUILD SYSTEM
     Dependencies managed via build.zig.zon:
         - sokol-zig: Cross-platform graphics/input
         - shdc: Shader compilation pipeline  
         - cimgui: Immediate mode GUI overlay

     Build commands:
         zig build              Build native executable
         zig build run          Build and run native
         zig build web          Build for web (WASM)

     Shader compilation:
         GLSL → {GLSL410, GLSL300ES, Metal, WGSL}
         Compile-time bytecode generation

     Web deployment:
         Output: zig-out/web/{fps.html, fps.js, fps.wasm}
         Serve via any HTTP server

EXAMPLES
     Basic voxel world with Quake physics:
         const Config = struct {
             pub const World = world.voxel;
             pub const Gfx = gfx.sokol(shaders.cube);
             pub const Body = phys.quake;
             pub const Keys = lib.input;
         };

     Empty world for testing:
         pub const World = world.empty;

     Alternative physics:
         pub const Body = phys.simple;

FILES
     ~/.config/engma/        User configuration directory
     ./build.zig            Build configuration
     ./build.zig.zon        Dependency manifest

DIAGNOSTICS
     The engine reports errors through standard Zig error handling.
     Graphics errors are handled by the sokol backend.
     Physics integration failures result in position clamping.

STANDARDS
     Follows Unix philosophy: do one thing well.
     Implements zero-cost abstractions per Zig design principles.
     Maintains <300 SLOC total for core engine logic.

HISTORY
     Derived from brutalist FPS demo architecture.
     Implements lessons learned from Quake engine design.
     Optimized for compile-time polymorphism and runtime performance.

AUTHORS
     Written in the spirit of computational minimalism.

SEE ALSO
     zig(1), sokol-gfx(3), glsl(7)

ENGMA                           October 2025                          ENGMA(1)